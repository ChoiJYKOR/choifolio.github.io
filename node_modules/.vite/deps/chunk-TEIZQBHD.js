import {
  $filter,
  $getNearestBlockElementAncestorOrThrow,
  addClassNamesToElement,
  mergeRegister,
  removeClassNamesFromElement
} from "./chunk-TLVVYBXE.js";
import {
  $create,
  $createNodeSelection,
  $createParagraphNode,
  $createRangeSelection,
  $getNodeByKey,
  $getNodeFromDOMNode,
  $getRoot,
  $getSelection,
  $isBlockElementNode,
  $isEditorState,
  $isNodeSelection,
  $isRangeSelection,
  $normalizeSelection,
  $setSelection,
  CLEAR_EDITOR_COMMAND,
  CLICK_COMMAND,
  COMMAND_PRIORITY_CRITICAL,
  COMMAND_PRIORITY_EDITOR,
  COMMAND_PRIORITY_LOW,
  DecoratorNode,
  HISTORY_MERGE_TAG,
  INDENT_CONTENT_COMMAND,
  INSERT_TAB_COMMAND,
  KEY_TAB_COMMAND,
  LineBreakNode,
  OUTDENT_CONTENT_COMMAND,
  ParagraphNode,
  RootNode,
  TabNode,
  TextNode,
  createCommand,
  createEditor,
  defineExtension,
  isDOMNode,
  safeCast,
  shallowMergeConfig
} from "./chunk-Z553WKUN.js";
import {
  __publicField
} from "./chunk-J32WSRGE.js";

// node_modules/@lexical/extension/LexicalExtension.dev.mjs
var i = Symbol.for("preact-signals");
function t() {
  if (r > 1) {
    r--;
    return;
  }
  let i2, t2 = false;
  while (void 0 !== s) {
    let o2 = s;
    s = void 0;
    f++;
    while (void 0 !== o2) {
      const n2 = o2.o;
      o2.o = void 0;
      o2.f &= -3;
      if (!(8 & o2.f) && v(o2))
        try {
          o2.c();
        } catch (o3) {
          if (!t2) {
            i2 = o3;
            t2 = true;
          }
        }
      o2 = n2;
    }
  }
  f = 0;
  r--;
  if (t2)
    throw i2;
}
function o(i2) {
  if (r > 0)
    return i2();
  r++;
  try {
    return i2();
  } finally {
    t();
  }
}
var n;
var s;
function h(i2) {
  const t2 = n;
  n = void 0;
  try {
    return i2();
  } finally {
    n = t2;
  }
}
var r = 0;
var f = 0;
var e = 0;
function u(i2) {
  if (void 0 === n)
    return;
  let t2 = i2.n;
  if (void 0 === t2 || t2.t !== n) {
    t2 = { i: 0, S: i2, p: n.s, n: void 0, t: n, e: void 0, x: void 0, r: t2 };
    if (void 0 !== n.s)
      n.s.n = t2;
    n.s = t2;
    i2.n = t2;
    if (32 & n.f)
      i2.S(t2);
    return t2;
  } else if (-1 === t2.i) {
    t2.i = 0;
    if (void 0 !== t2.n) {
      t2.n.p = t2.p;
      if (void 0 !== t2.p)
        t2.p.n = t2.n;
      t2.p = n.s;
      t2.n = void 0;
      n.s.n = t2;
      n.s = t2;
    }
    return t2;
  }
}
function c(i2, t2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
  this.name = null == t2 ? void 0 : t2.name;
}
c.prototype.brand = i;
c.prototype.h = function() {
  return true;
};
c.prototype.S = function(i2) {
  const t2 = this.t;
  if (t2 !== i2 && void 0 === i2.e) {
    i2.x = t2;
    this.t = i2;
    if (void 0 !== t2)
      t2.e = i2;
    else
      h(() => {
        var i3;
        null == (i3 = this.W) || i3.call(this);
      });
  }
};
c.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    const t2 = i2.e, o2 = i2.x;
    if (void 0 !== t2) {
      t2.x = o2;
      i2.e = void 0;
    }
    if (void 0 !== o2) {
      o2.e = t2;
      i2.x = void 0;
    }
    if (i2 === this.t) {
      this.t = o2;
      if (void 0 === o2)
        h(() => {
          var i3;
          null == (i3 = this.Z) || i3.call(this);
        });
    }
  }
};
c.prototype.subscribe = function(i2) {
  return E(() => {
    const t2 = this.value, o2 = n;
    n = void 0;
    try {
      i2(t2);
    } finally {
      n = o2;
    }
  }, { name: "sub" });
};
c.prototype.valueOf = function() {
  return this.value;
};
c.prototype.toString = function() {
  return this.value + "";
};
c.prototype.toJSON = function() {
  return this.value;
};
c.prototype.peek = function() {
  const i2 = n;
  n = void 0;
  try {
    return this.value;
  } finally {
    n = i2;
  }
};
Object.defineProperty(c.prototype, "value", { get() {
  const i2 = u(this);
  if (void 0 !== i2)
    i2.i = this.i;
  return this.v;
}, set(i2) {
  if (i2 !== this.v) {
    if (f > 100)
      throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    e++;
    r++;
    try {
      for (let i3 = this.t; void 0 !== i3; i3 = i3.x)
        i3.t.N();
    } finally {
      t();
    }
  }
} });
function d(i2, t2) {
  return new c(i2, t2);
}
function v(i2) {
  for (let t2 = i2.s; void 0 !== t2; t2 = t2.n)
    if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i)
      return true;
  return false;
}
function l(i2) {
  for (let t2 = i2.s; void 0 !== t2; t2 = t2.n) {
    const o2 = t2.S.n;
    if (void 0 !== o2)
      t2.r = o2;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i2.s = t2;
      break;
    }
  }
}
function y(i2) {
  let t2, o2 = i2.s;
  while (void 0 !== o2) {
    const i3 = o2.p;
    if (-1 === o2.i) {
      o2.S.U(o2);
      if (void 0 !== i3)
        i3.n = o2.n;
      if (void 0 !== o2.n)
        o2.n.p = i3;
    } else
      t2 = o2;
    o2.S.n = o2.r;
    if (void 0 !== o2.r)
      o2.r = void 0;
    o2 = i3;
  }
  i2.s = t2;
}
function a(i2, t2) {
  c.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = e - 1;
  this.f = 4;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
  this.name = null == t2 ? void 0 : t2.name;
}
a.prototype = new c();
a.prototype.h = function() {
  this.f &= -3;
  if (1 & this.f)
    return false;
  if (32 == (36 & this.f))
    return true;
  this.f &= -5;
  if (this.g === e)
    return true;
  this.g = e;
  this.f |= 1;
  if (this.i > 0 && !v(this)) {
    this.f &= -2;
    return true;
  }
  const i2 = n;
  try {
    l(this);
    n = this;
    const i3 = this.x();
    if (16 & this.f || this.v !== i3 || 0 === this.i) {
      this.v = i3;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  n = i2;
  y(this);
  this.f &= -2;
  return true;
};
a.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (let i3 = this.s; void 0 !== i3; i3 = i3.n)
      i3.S.S(i3);
  }
  c.prototype.S.call(this, i2);
};
a.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    c.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (let i3 = this.s; void 0 !== i3; i3 = i3.n)
        i3.S.U(i3);
    }
  }
};
a.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (let i2 = this.t; void 0 !== i2; i2 = i2.x)
      i2.t.N();
  }
};
Object.defineProperty(a.prototype, "value", { get() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  const i2 = u(this);
  this.h();
  if (void 0 !== i2)
    i2.i = this.i;
  if (16 & this.f)
    throw this.v;
  return this.v;
} });
function w(i2, t2) {
  return new a(i2, t2);
}
function _(i2) {
  const o2 = i2.u;
  i2.u = void 0;
  if ("function" == typeof o2) {
    r++;
    const s2 = n;
    n = void 0;
    try {
      o2();
    } catch (t2) {
      i2.f &= -2;
      i2.f |= 8;
      b(i2);
      throw t2;
    } finally {
      n = s2;
      t();
    }
  }
}
function b(i2) {
  for (let t2 = i2.s; void 0 !== t2; t2 = t2.n)
    t2.S.U(t2);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function g(i2) {
  if (n !== this)
    throw new Error("Out-of-order effect");
  y(this);
  n = i2;
  this.f &= -2;
  if (8 & this.f)
    b(this);
  t();
}
function p(i2, t2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
  this.name = null == t2 ? void 0 : t2.name;
}
p.prototype.c = function() {
  const i2 = this.S();
  try {
    if (8 & this.f)
      return;
    if (void 0 === this.x)
      return;
    const t2 = this.x();
    if ("function" == typeof t2)
      this.u = t2;
  } finally {
    i2();
  }
};
p.prototype.S = function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  l(this);
  r++;
  const i2 = n;
  n = this;
  return g.bind(this, i2);
};
p.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = s;
    s = this;
  }
};
p.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f))
    b(this);
};
p.prototype.dispose = function() {
  this.d();
};
function E(i2, t2) {
  const o2 = new p(i2, t2);
  try {
    o2.c();
  } catch (i3) {
    o2.d();
    throw i3;
  }
  const n2 = o2.d.bind(o2);
  n2[Symbol.dispose] = n2;
  return n2;
}
function namedSignals(defaults, opts = {}) {
  const initial = {};
  for (const k in defaults) {
    const v2 = opts[k];
    const store = d(v2 === void 0 ? defaults[k] : v2);
    initial[k] = store;
  }
  return initial;
}
var AutoFocusExtension = defineExtension({
  build: (editor, config, state) => {
    return namedSignals(config);
  },
  config: safeCast({
    defaultSelection: "rootEnd",
    disabled: false
  }),
  name: "@lexical/extension/AutoFocus",
  register(editor, config, state) {
    const stores = state.getOutput();
    return E(() => stores.disabled.value ? void 0 : editor.registerRootListener((rootElement) => {
      editor.focus(() => {
        const activeElement = document.activeElement;
        if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {
          rootElement.focus({
            preventScroll: true
          });
        }
      }, {
        defaultSelection: stores.defaultSelection.peek()
      });
    }));
  }
});
function $defaultOnClear() {
  const root = $getRoot();
  const selection = $getSelection();
  const paragraph = $createParagraphNode();
  root.clear();
  root.append(paragraph);
  if (selection !== null) {
    paragraph.select();
  }
  if ($isRangeSelection(selection)) {
    selection.format = 0;
  }
}
function registerClearEditor(editor, $onClear = $defaultOnClear) {
  return editor.registerCommand(CLEAR_EDITOR_COMMAND, (payload) => {
    editor.update($onClear);
    return true;
  }, COMMAND_PRIORITY_EDITOR);
}
var ClearEditorExtension = defineExtension({
  build(editor, config, state) {
    return namedSignals(config);
  },
  config: safeCast({
    $onClear: $defaultOnClear
  }),
  name: "@lexical/extension/ClearEditor",
  register(editor, config, state) {
    const {
      $onClear
    } = state.getOutput();
    return E(() => registerClearEditor(editor, $onClear.value));
  }
});
function watchedSignal(getSnapshot, register) {
  let dispose;
  return d(getSnapshot(), {
    unwatched() {
      if (dispose) {
        dispose();
        dispose = void 0;
      }
    },
    watched() {
      this.value = getSnapshot();
      dispose = register(this);
    }
  });
}
var EditorStateExtension = defineExtension({
  build(editor) {
    return watchedSignal(() => editor.getEditorState(), (editorStateSignal) => editor.registerUpdateListener((payload) => {
      editorStateSignal.value = payload.editorState;
    }));
  },
  name: "@lexical/extension/EditorState"
});
function formatDevErrorMessage(message) {
  throw new Error(message);
}
function deepThemeMergeInPlace(a2, b2) {
  if (a2 && b2 && !Array.isArray(b2) && typeof a2 === "object" && typeof b2 === "object") {
    const aObj = a2;
    const bObj = b2;
    for (const k in bObj) {
      aObj[k] = deepThemeMergeInPlace(aObj[k], bObj[k]);
    }
    return a2;
  }
  return b2;
}
var ExtensionRepStateIds = {
  /* eslint-disable sort-keys-fix/sort-keys-fix */
  unmarked: 0,
  temporary: 1,
  permanent: 2,
  configured: 3,
  initialized: 4,
  built: 5,
  registered: 6,
  afterRegistration: 7
  /* eslint-enable sort-keys-fix/sort-keys-fix */
};
function isExactlyUnmarkedExtensionRepState(state) {
  return state.id === ExtensionRepStateIds.unmarked;
}
function isExactlyTemporaryExtensionRepState(state) {
  return state.id === ExtensionRepStateIds.temporary;
}
function isExactlyPermanentExtensionRepState(state) {
  return state.id === ExtensionRepStateIds.permanent;
}
function isConfiguredExtensionRepState(state) {
  return state.id >= ExtensionRepStateIds.configured;
}
function isInitializedExtensionRepState(state) {
  return state.id >= ExtensionRepStateIds.initialized;
}
function isBuiltExtensionRepState(state) {
  return state.id >= ExtensionRepStateIds.built;
}
function isAfterRegistrationState(state) {
  return state.id >= ExtensionRepStateIds.afterRegistration;
}
function applyTemporaryMark(state) {
  if (!isExactlyUnmarkedExtensionRepState(state)) {
    formatDevErrorMessage(`LexicalBuilder: Can not apply a temporary mark from state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.unmarked)} unmarked)`);
  }
  return Object.assign(state, {
    id: ExtensionRepStateIds.temporary
  });
}
function applyPermanentMark(state) {
  if (!isExactlyTemporaryExtensionRepState(state)) {
    formatDevErrorMessage(`LexicalBuilder: Can not apply a permanent mark from state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.temporary)} temporary)`);
  }
  return Object.assign(state, {
    id: ExtensionRepStateIds.permanent
  });
}
function applyConfiguredState(state, config, registerState) {
  return Object.assign(state, {
    config,
    id: ExtensionRepStateIds.configured,
    registerState
  });
}
function applyInitializedState(state, initResult, registerState) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.initialized,
    initResult,
    registerState
  });
}
function applyBuiltState(state, output, registerState) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.built,
    output,
    registerState
  });
}
function applyRegisteredState(state) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.registered
  });
}
function applyAfterRegistrationState(state) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.afterRegistration
  });
}
function rollbackToBuiltState(state) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.built
  });
}
var emptySet = /* @__PURE__ */ new Set();
var ExtensionRep = class {
  constructor(builder, extension) {
    __publicField(this, "builder");
    __publicField(this, "configs");
    __publicField(this, "_dependency");
    __publicField(this, "_peerNameSet");
    __publicField(this, "extension");
    __publicField(this, "state");
    __publicField(this, "_signal");
    this.builder = builder;
    this.extension = extension;
    this.configs = /* @__PURE__ */ new Set();
    this.state = {
      id: ExtensionRepStateIds.unmarked
    };
  }
  mergeConfigs() {
    let config = this.extension.config || {};
    const mergeConfig = this.extension.mergeConfig ? this.extension.mergeConfig.bind(this.extension) : shallowMergeConfig;
    for (const cfg of this.configs) {
      config = mergeConfig(config, cfg);
    }
    return config;
  }
  init(editorConfig) {
    const initialState = this.state;
    if (!isExactlyPermanentExtensionRepState(initialState)) {
      formatDevErrorMessage(`ExtensionRep: Can not configure from state id ${String(initialState.id)}`);
    }
    const initState = {
      getDependency: this.getInitDependency.bind(this),
      getDirectDependentNames: this.getDirectDependentNames.bind(this),
      getPeer: this.getInitPeer.bind(this),
      getPeerNameSet: this.getPeerNameSet.bind(this)
    };
    const buildState = {
      ...initState,
      getDependency: this.getDependency.bind(this),
      getInitResult: this.getInitResult.bind(this),
      getPeer: this.getPeer.bind(this)
    };
    const state = applyConfiguredState(initialState, this.mergeConfigs(), initState);
    this.state = state;
    let initResult;
    if (this.extension.init) {
      initResult = this.extension.init(editorConfig, state.config, initState);
    }
    this.state = applyInitializedState(state, initResult, buildState);
  }
  build(editor) {
    const state = this.state;
    if (!(state.id === ExtensionRepStateIds.initialized)) {
      formatDevErrorMessage(`ExtensionRep: register called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.built)} initialized)`);
    }
    let output;
    if (this.extension.build) {
      output = this.extension.build(editor, state.config, state.registerState);
    }
    const registerState = {
      ...state.registerState,
      getOutput: () => output,
      getSignal: this.getSignal.bind(this)
    };
    this.state = applyBuiltState(state, output, registerState);
  }
  register(editor, signal) {
    this._signal = signal;
    const state = this.state;
    if (!(state.id === ExtensionRepStateIds.built)) {
      formatDevErrorMessage(`ExtensionRep: register called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.built)} built)`);
    }
    const cleanup = this.extension.register && this.extension.register(editor, state.config, state.registerState);
    this.state = applyRegisteredState(state);
    return () => {
      const afterRegistrationState = this.state;
      if (!(afterRegistrationState.id === ExtensionRepStateIds.afterRegistration)) {
        formatDevErrorMessage(`ExtensionRep: rollbackToBuiltState called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.afterRegistration)} afterRegistration)`);
      }
      this.state = rollbackToBuiltState(afterRegistrationState);
      if (cleanup) {
        cleanup();
      }
    };
  }
  afterRegistration(editor) {
    const state = this.state;
    if (!(state.id === ExtensionRepStateIds.registered)) {
      formatDevErrorMessage(`ExtensionRep: afterRegistration called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.registered)} registered)`);
    }
    let rval;
    if (this.extension.afterRegistration) {
      rval = this.extension.afterRegistration(editor, state.config, state.registerState);
    }
    this.state = applyAfterRegistrationState(state);
    return rval;
  }
  getSignal() {
    if (!(this._signal !== void 0)) {
      formatDevErrorMessage(`ExtensionRep.getSignal() called before register`);
    }
    return this._signal;
  }
  getInitResult() {
    if (!(this.extension.init !== void 0)) {
      formatDevErrorMessage(`ExtensionRep: getInitResult() called for Extension ${this.extension.name} that does not define init`);
    }
    const state = this.state;
    if (!isInitializedExtensionRepState(state)) {
      formatDevErrorMessage(`ExtensionRep: getInitResult() called for ExtensionRep in state id ${String(state.id)} < ${String(ExtensionRepStateIds.initialized)} (initialized)`);
    }
    return state.initResult;
  }
  getInitPeer(name) {
    const rep = this.builder.extensionNameMap.get(name);
    return rep ? rep.getExtensionInitDependency() : void 0;
  }
  getExtensionInitDependency() {
    const state = this.state;
    if (!isConfiguredExtensionRepState(state)) {
      formatDevErrorMessage(`ExtensionRep: getExtensionInitDependency called in state id ${String(state.id)} (expected >= ${String(ExtensionRepStateIds.configured)} configured)`);
    }
    return {
      config: state.config
    };
  }
  getPeer(name) {
    const rep = this.builder.extensionNameMap.get(name);
    return rep ? rep.getExtensionDependency() : void 0;
  }
  getInitDependency(dep) {
    const rep = this.builder.getExtensionRep(dep);
    if (!(rep !== void 0)) {
      formatDevErrorMessage(`LexicalExtensionBuilder: Extension ${this.extension.name} missing dependency extension ${dep.name} to be in registry`);
    }
    return rep.getExtensionInitDependency();
  }
  getDependency(dep) {
    const rep = this.builder.getExtensionRep(dep);
    if (!(rep !== void 0)) {
      formatDevErrorMessage(`LexicalExtensionBuilder: Extension ${this.extension.name} missing dependency extension ${dep.name} to be in registry`);
    }
    return rep.getExtensionDependency();
  }
  getState() {
    const state = this.state;
    if (!isAfterRegistrationState(state)) {
      formatDevErrorMessage(`ExtensionRep getState called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.afterRegistration)} afterRegistration)`);
    }
    return state;
  }
  getDirectDependentNames() {
    return this.builder.incomingEdges.get(this.extension.name) || emptySet;
  }
  getPeerNameSet() {
    let s2 = this._peerNameSet;
    if (!s2) {
      s2 = new Set((this.extension.peerDependencies || []).map(([name]) => name));
      this._peerNameSet = s2;
    }
    return s2;
  }
  getExtensionDependency() {
    if (!this._dependency) {
      const state = this.state;
      if (!isBuiltExtensionRepState(state)) {
        formatDevErrorMessage(`Extension ${this.extension.name} used as a dependency before build`);
      }
      this._dependency = {
        config: state.config,
        init: state.initResult,
        output: state.output
      };
    }
    return this._dependency;
  }
};
var HISTORY_MERGE_OPTIONS = {
  tag: HISTORY_MERGE_TAG
};
function $defaultInitializer() {
  const root = $getRoot();
  if (root.isEmpty()) {
    root.append($createParagraphNode());
  }
}
var InitialStateExtension = defineExtension({
  config: safeCast({
    setOptions: HISTORY_MERGE_OPTIONS,
    updateOptions: HISTORY_MERGE_OPTIONS
  }),
  init({
    $initialEditorState = $defaultInitializer
  }) {
    return {
      $initialEditorState,
      initialized: false
    };
  },
  // eslint-disable-next-line sort-keys-fix/sort-keys-fix -- typescript inference is order dependent here for some reason
  afterRegistration(editor, {
    updateOptions,
    setOptions
  }, state) {
    const initResult = state.getInitResult();
    if (!initResult.initialized) {
      initResult.initialized = true;
      const {
        $initialEditorState
      } = initResult;
      if ($isEditorState($initialEditorState)) {
        editor.setEditorState($initialEditorState, setOptions);
      } else if (typeof $initialEditorState === "function") {
        editor.update(() => {
          $initialEditorState(editor);
        }, updateOptions);
      } else if ($initialEditorState && (typeof $initialEditorState === "string" || typeof $initialEditorState === "object")) {
        const parsedEditorState = editor.parseEditorState($initialEditorState);
        editor.setEditorState(parsedEditorState, setOptions);
      }
    }
    return () => {
    };
  },
  name: "@lexical/extension/InitialState",
  // These are automatically added by createEditor, we add them here so they are
  // visible during extensionRep.init so extensions can see all known types before the
  // editor is created.
  // (excluding ArtificialNode__DO_NOT_USE because it isn't really public API
  // and shouldn't change anything)
  nodes: [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode]
});
var builderSymbol = Symbol.for("@lexical/extension/LexicalBuilder");
function noop() {
}
function defaultOnError(err) {
  throw err;
}
function maybeWithBuilder(editor) {
  return editor;
}
function normalizeExtensionArgument(arg) {
  return Array.isArray(arg) ? arg : [arg];
}
var PACKAGE_VERSION = "0.37.0+dev.esm";
var LexicalBuilder = class _LexicalBuilder {
  constructor(roots) {
    __publicField(this, "roots");
    __publicField(this, "extensionNameMap");
    __publicField(this, "outgoingConfigEdges");
    __publicField(this, "incomingEdges");
    __publicField(this, "conflicts");
    __publicField(this, "_sortedExtensionReps");
    __publicField(this, "PACKAGE_VERSION");
    this.outgoingConfigEdges = /* @__PURE__ */ new Map();
    this.incomingEdges = /* @__PURE__ */ new Map();
    this.extensionNameMap = /* @__PURE__ */ new Map();
    this.conflicts = /* @__PURE__ */ new Map();
    this.PACKAGE_VERSION = PACKAGE_VERSION;
    this.roots = roots;
    for (const extension of roots) {
      this.addExtension(extension);
    }
  }
  static fromExtensions(extensions) {
    const roots = [normalizeExtensionArgument(InitialStateExtension)];
    for (const extension of extensions) {
      roots.push(normalizeExtensionArgument(extension));
    }
    return new _LexicalBuilder(roots);
  }
  static maybeFromEditor(editor) {
    const builder = maybeWithBuilder(editor)[builderSymbol];
    if (builder) {
      if (!(builder.PACKAGE_VERSION === PACKAGE_VERSION)) {
        formatDevErrorMessage(`LexicalBuilder.fromEditor: The given editor was created with LexicalBuilder ${builder.PACKAGE_VERSION} but this version is ${PACKAGE_VERSION}. A project should have exactly one copy of LexicalBuilder`);
      }
      if (!(builder instanceof _LexicalBuilder)) {
        formatDevErrorMessage(`LexicalBuilder.fromEditor: There are multiple copies of the same version of LexicalBuilder in your project, and this editor was created with another one. Your project, or one of its dependencies, has its package.json and/or bundler configured incorrectly.`);
      }
    }
    return builder;
  }
  /** Look up the editor that was created by this LexicalBuilder or throw */
  static fromEditor(editor) {
    const builder = _LexicalBuilder.maybeFromEditor(editor);
    if (!(builder !== void 0)) {
      formatDevErrorMessage(`LexicalBuilder.fromEditor: The given editor was not created with LexicalBuilder`);
    }
    return builder;
  }
  constructEditor() {
    const {
      $initialEditorState: _$initialEditorState,
      onError,
      ...editorConfig
    } = this.buildCreateEditorArgs();
    const editor = Object.assign(createEditor({
      ...editorConfig,
      ...onError ? {
        onError: (err) => {
          onError(err, editor);
        }
      } : {}
    }), {
      [builderSymbol]: this
    });
    for (const extensionRep of this.sortedExtensionReps()) {
      extensionRep.build(editor);
    }
    return editor;
  }
  buildEditor() {
    let disposeOnce = noop;
    function dispose() {
      try {
        disposeOnce();
      } finally {
        disposeOnce = noop;
      }
    }
    const editor = Object.assign(this.constructEditor(), {
      dispose,
      [Symbol.dispose]: dispose
    });
    disposeOnce = mergeRegister(this.registerEditor(editor), () => editor.setRootElement(null));
    return editor;
  }
  hasExtensionByName(name) {
    return this.extensionNameMap.has(name);
  }
  getExtensionRep(extension) {
    const rep = this.extensionNameMap.get(extension.name);
    if (rep) {
      if (!(rep.extension === extension)) {
        formatDevErrorMessage(`LexicalBuilder: A registered extension with name ${extension.name} exists but does not match the given extension`);
      }
      return rep;
    }
  }
  addEdge(fromExtensionName, toExtensionName, configs) {
    const outgoing = this.outgoingConfigEdges.get(fromExtensionName);
    if (outgoing) {
      outgoing.set(toExtensionName, configs);
    } else {
      this.outgoingConfigEdges.set(fromExtensionName, /* @__PURE__ */ new Map([[toExtensionName, configs]]));
    }
    const incoming = this.incomingEdges.get(toExtensionName);
    if (incoming) {
      incoming.add(fromExtensionName);
    } else {
      this.incomingEdges.set(toExtensionName, /* @__PURE__ */ new Set([fromExtensionName]));
    }
  }
  addExtension(arg) {
    if (!(this._sortedExtensionReps === void 0)) {
      formatDevErrorMessage(`LexicalBuilder: addExtension called after finalization`);
    }
    const normalized = normalizeExtensionArgument(arg);
    const [extension] = normalized;
    if (!(typeof extension.name === "string")) {
      formatDevErrorMessage(`LexicalBuilder: extension name must be string, not ${typeof extension.name}`);
    }
    let extensionRep = this.extensionNameMap.get(extension.name);
    if (!(extensionRep === void 0 || extensionRep.extension === extension)) {
      formatDevErrorMessage(`LexicalBuilder: Multiple extensions registered with name ${extension.name}, names must be unique`);
    }
    if (!extensionRep) {
      extensionRep = new ExtensionRep(this, extension);
      this.extensionNameMap.set(extension.name, extensionRep);
      const hasConflict = this.conflicts.get(extension.name);
      if (typeof hasConflict === "string") {
        {
          formatDevErrorMessage(`LexicalBuilder: extension ${extension.name} conflicts with ${hasConflict}`);
        }
      }
      for (const name of extension.conflictsWith || []) {
        if (!!this.extensionNameMap.has(name)) {
          formatDevErrorMessage(`LexicalBuilder: extension ${extension.name} conflicts with ${name}`);
        }
        this.conflicts.set(name, extension.name);
      }
      for (const dep of extension.dependencies || []) {
        const normDep = normalizeExtensionArgument(dep);
        this.addEdge(extension.name, normDep[0].name, normDep.slice(1));
        this.addExtension(normDep);
      }
      for (const [depName, config] of extension.peerDependencies || []) {
        this.addEdge(extension.name, depName, config ? [config] : []);
      }
    }
  }
  sortedExtensionReps() {
    if (this._sortedExtensionReps) {
      return this._sortedExtensionReps;
    }
    const sortedExtensionReps = [];
    const visit = (rep, fromExtensionName) => {
      let mark = rep.state;
      if (isExactlyPermanentExtensionRepState(mark)) {
        return;
      }
      const extensionName = rep.extension.name;
      if (!isExactlyUnmarkedExtensionRepState(mark)) {
        formatDevErrorMessage(`LexicalBuilder: Circular dependency detected for Extension ${extensionName} from ${fromExtensionName || "[unknown]"}`);
      }
      mark = applyTemporaryMark(mark);
      rep.state = mark;
      const outgoingConfigEdges = this.outgoingConfigEdges.get(extensionName);
      if (outgoingConfigEdges) {
        for (const toExtensionName of outgoingConfigEdges.keys()) {
          const toRep = this.extensionNameMap.get(toExtensionName);
          if (toRep) {
            visit(toRep, extensionName);
          }
        }
      }
      mark = applyPermanentMark(mark);
      rep.state = mark;
      sortedExtensionReps.push(rep);
    };
    for (const rep of this.extensionNameMap.values()) {
      if (isExactlyUnmarkedExtensionRepState(rep.state)) {
        visit(rep);
      }
    }
    for (const rep of sortedExtensionReps) {
      for (const [toExtensionName, configs] of this.outgoingConfigEdges.get(rep.extension.name) || []) {
        if (configs.length > 0) {
          const toRep = this.extensionNameMap.get(toExtensionName);
          if (toRep) {
            for (const config of configs) {
              toRep.configs.add(config);
            }
          }
        }
      }
    }
    for (const [extension, ...configs] of this.roots) {
      if (configs.length > 0) {
        const toRep = this.extensionNameMap.get(extension.name);
        if (!(toRep !== void 0)) {
          formatDevErrorMessage(`LexicalBuilder: Expecting existing ExtensionRep for ${extension.name}`);
        }
        for (const config of configs) {
          toRep.configs.add(config);
        }
      }
    }
    this._sortedExtensionReps = sortedExtensionReps;
    return this._sortedExtensionReps;
  }
  registerEditor(editor) {
    const extensionReps = this.sortedExtensionReps();
    const controller = new AbortController();
    const cleanups = [() => controller.abort()];
    const signal = controller.signal;
    for (const extensionRep of extensionReps) {
      const cleanup = extensionRep.register(editor, signal);
      if (cleanup) {
        cleanups.push(cleanup);
      }
    }
    for (const extensionRep of extensionReps) {
      const cleanup = extensionRep.afterRegistration(editor);
      if (cleanup) {
        cleanups.push(cleanup);
      }
    }
    return mergeRegister(...cleanups);
  }
  buildCreateEditorArgs() {
    const config = {};
    const nodes = /* @__PURE__ */ new Set();
    const replacedNodes = /* @__PURE__ */ new Map();
    const htmlExport = /* @__PURE__ */ new Map();
    const htmlImport = {};
    const theme = {};
    const extensionReps = this.sortedExtensionReps();
    for (const extensionRep of extensionReps) {
      const {
        extension
      } = extensionRep;
      if (extension.onError !== void 0) {
        config.onError = extension.onError;
      }
      if (extension.disableEvents !== void 0) {
        config.disableEvents = extension.disableEvents;
      }
      if (extension.parentEditor !== void 0) {
        config.parentEditor = extension.parentEditor;
      }
      if (extension.editable !== void 0) {
        config.editable = extension.editable;
      }
      if (extension.namespace !== void 0) {
        config.namespace = extension.namespace;
      }
      if (extension.$initialEditorState !== void 0) {
        config.$initialEditorState = extension.$initialEditorState;
      }
      if (extension.nodes) {
        for (const node of extension.nodes) {
          if (typeof node !== "function") {
            const conflictExtension = replacedNodes.get(node.replace);
            if (conflictExtension) {
              {
                formatDevErrorMessage(`LexicalBuilder: Extension ${extension.name} can not register replacement for node ${node.replace.name} because ${conflictExtension.extension.name} already did`);
              }
            }
            replacedNodes.set(node.replace, extensionRep);
          }
          nodes.add(node);
        }
      }
      if (extension.html) {
        if (extension.html.export) {
          for (const [k, v2] of extension.html.export.entries()) {
            htmlExport.set(k, v2);
          }
        }
        if (extension.html.import) {
          Object.assign(htmlImport, extension.html.import);
        }
      }
      if (extension.theme) {
        deepThemeMergeInPlace(theme, extension.theme);
      }
    }
    if (Object.keys(theme).length > 0) {
      config.theme = theme;
    }
    if (nodes.size) {
      config.nodes = [...nodes];
    }
    const hasImport = Object.keys(htmlImport).length > 0;
    const hasExport = htmlExport.size > 0;
    if (hasImport || hasExport) {
      config.html = {};
      if (hasImport) {
        config.html.import = htmlImport;
      }
      if (hasExport) {
        config.html.export = htmlExport;
      }
    }
    for (const extensionRep of extensionReps) {
      extensionRep.init(config);
    }
    if (!config.onError) {
      config.onError = defaultOnError;
    }
    return config;
  }
};
function getPeerDependencyFromEditor(editor, extensionName) {
  const builder = LexicalBuilder.fromEditor(editor);
  const peer = builder.extensionNameMap.get(extensionName);
  return peer ? peer.getExtensionDependency() : void 0;
}
var EMPTY_SET = /* @__PURE__ */ new Set();
var NodeSelectionExtension = defineExtension({
  build(editor, config, state) {
    const editorStateStore = state.getDependency(EditorStateExtension).output;
    const watchedNodeStore = d({
      watchedNodeKeys: /* @__PURE__ */ new Map()
    });
    const selectedNodeKeys = watchedSignal(() => void 0, () => E(() => {
      const prevSelectedNodeKeys = selectedNodeKeys.peek();
      const {
        watchedNodeKeys
      } = watchedNodeStore.value;
      let nextSelectedNodeKeys;
      let didChange = false;
      editorStateStore.value.read(() => {
        const selection = $getSelection();
        if (selection) {
          for (const [key, listeners] of watchedNodeKeys.entries()) {
            if (listeners.size === 0) {
              watchedNodeKeys.delete(key);
              continue;
            }
            const node = $getNodeByKey(key);
            const isSelected = node && node.isSelected() || false;
            didChange = didChange || isSelected !== (prevSelectedNodeKeys ? prevSelectedNodeKeys.has(key) : false);
            if (isSelected) {
              nextSelectedNodeKeys = nextSelectedNodeKeys || /* @__PURE__ */ new Set();
              nextSelectedNodeKeys.add(key);
            }
          }
        }
      });
      if (!(!didChange && nextSelectedNodeKeys && prevSelectedNodeKeys && nextSelectedNodeKeys.size === prevSelectedNodeKeys.size)) {
        selectedNodeKeys.value = nextSelectedNodeKeys;
      }
    }));
    function watchNodeKey(key) {
      const watcher = w(() => (selectedNodeKeys.value || EMPTY_SET).has(key));
      const {
        watchedNodeKeys
      } = watchedNodeStore.peek();
      let listeners = watchedNodeKeys.get(key);
      const hadListener = listeners !== void 0;
      listeners = listeners || /* @__PURE__ */ new Set();
      listeners.add(watcher);
      if (!hadListener) {
        watchedNodeKeys.set(key, listeners);
        watchedNodeStore.value = {
          watchedNodeKeys
        };
      }
      return watcher;
    }
    return {
      watchNodeKey
    };
  },
  dependencies: [EditorStateExtension],
  name: "@lexical/extension/NodeSelection"
});
var INSERT_HORIZONTAL_RULE_COMMAND = createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
var HorizontalRuleNode = class _HorizontalRuleNode extends DecoratorNode {
  static getType() {
    return "horizontalrule";
  }
  static clone(node) {
    return new _HorizontalRuleNode(node.__key);
  }
  static importJSON(serializedNode) {
    return $createHorizontalRuleNode().updateFromJSON(serializedNode);
  }
  static importDOM() {
    return {
      hr: () => ({
        conversion: $convertHorizontalRuleElement,
        priority: 0
      })
    };
  }
  exportDOM() {
    return {
      element: document.createElement("hr")
    };
  }
  createDOM(config) {
    const element = document.createElement("hr");
    addClassNamesToElement(element, config.theme.hr);
    return element;
  }
  getTextContent() {
    return "\n";
  }
  isInline() {
    return false;
  }
  updateDOM() {
    return false;
  }
};
function $convertHorizontalRuleElement() {
  return {
    node: $createHorizontalRuleNode()
  };
}
function $createHorizontalRuleNode() {
  return $create(HorizontalRuleNode);
}
function $isHorizontalRuleNode(node) {
  return node instanceof HorizontalRuleNode;
}
function $toggleNodeSelection(node, shiftKey = false) {
  const selection = $getSelection();
  const wasSelected = node.isSelected();
  const key = node.getKey();
  let nodeSelection;
  if (shiftKey && $isNodeSelection(selection)) {
    nodeSelection = selection;
  } else {
    nodeSelection = $createNodeSelection();
    $setSelection(nodeSelection);
  }
  if (wasSelected) {
    nodeSelection.delete(key);
  } else {
    nodeSelection.add(key);
  }
}
var HorizontalRuleExtension = defineExtension({
  dependencies: [EditorStateExtension, NodeSelectionExtension],
  name: "@lexical/extension/HorizontalRule",
  nodes: [HorizontalRuleNode],
  register(editor, config, state) {
    const {
      watchNodeKey
    } = state.getDependency(NodeSelectionExtension).output;
    const nodeSelectionStore = d({
      nodeSelections: /* @__PURE__ */ new Map()
    });
    const isSelectedClassName = editor._config.theme.hrSelected ?? "selected";
    return mergeRegister(editor.registerCommand(CLICK_COMMAND, (event) => {
      if (isDOMNode(event.target)) {
        const node = $getNodeFromDOMNode(event.target);
        if ($isHorizontalRuleNode(node)) {
          $toggleNodeSelection(node, event.shiftKey);
          return true;
        }
      }
      return false;
    }, COMMAND_PRIORITY_LOW), editor.registerMutationListener(HorizontalRuleNode, (nodes, payload) => {
      o(() => {
        let didChange = false;
        const {
          nodeSelections
        } = nodeSelectionStore.peek();
        for (const [k, v2] of nodes.entries()) {
          if (v2 === "destroyed") {
            nodeSelections.delete(k);
            didChange = true;
          } else {
            const prev = nodeSelections.get(k);
            const dom = editor.getElementByKey(k);
            if (prev) {
              prev.domNode.value = dom;
            } else {
              didChange = true;
              nodeSelections.set(k, {
                domNode: d(dom),
                selectedSignal: watchNodeKey(k)
              });
            }
          }
        }
        if (didChange) {
          nodeSelectionStore.value = {
            nodeSelections
          };
        }
      });
    }), E(() => {
      const effects = [];
      for (const {
        domNode,
        selectedSignal
      } of nodeSelectionStore.value.nodeSelections.values()) {
        effects.push(E(() => {
          const dom = domNode.value;
          if (dom) {
            const isSelected = selectedSignal.value;
            if (isSelected) {
              addClassNamesToElement(dom, isSelectedClassName);
            } else {
              removeClassNamesFromElement(dom, isSelectedClassName);
            }
          }
        }));
      }
      return mergeRegister(...effects);
    }));
  }
});
function $indentOverTab(selection) {
  const nodes = selection.getNodes();
  const canIndentBlockNodes = $filter(nodes, (node) => {
    if ($isBlockElementNode(node) && node.canIndent()) {
      return node;
    }
    return null;
  });
  if (canIndentBlockNodes.length > 0) {
    return true;
  }
  const anchor = selection.anchor;
  const focus = selection.focus;
  const first = focus.isBefore(anchor) ? focus : anchor;
  const firstNode = first.getNode();
  const firstBlock = $getNearestBlockElementAncestorOrThrow(firstNode);
  if (firstBlock.canIndent()) {
    const firstBlockKey = firstBlock.getKey();
    let selectionAtStart = $createRangeSelection();
    selectionAtStart.anchor.set(firstBlockKey, 0, "element");
    selectionAtStart.focus.set(firstBlockKey, 0, "element");
    selectionAtStart = $normalizeSelection(selectionAtStart);
    if (selectionAtStart.anchor.is(first)) {
      return true;
    }
  }
  return false;
}
function registerTabIndentation(editor, maxIndent) {
  return mergeRegister(editor.registerCommand(KEY_TAB_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    event.preventDefault();
    const command = $indentOverTab(selection) ? event.shiftKey ? OUTDENT_CONTENT_COMMAND : INDENT_CONTENT_COMMAND : INSERT_TAB_COMMAND;
    return editor.dispatchCommand(command, void 0);
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {
    const currentMaxIndent = typeof maxIndent === "number" ? maxIndent : maxIndent ? maxIndent.peek() : null;
    if (currentMaxIndent == null) {
      return false;
    }
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    const indents = selection.getNodes().map((node) => $getNearestBlockElementAncestorOrThrow(node).getIndent());
    return Math.max(...indents) + 1 >= currentMaxIndent;
  }, COMMAND_PRIORITY_CRITICAL));
}
var TabIndentationExtension = defineExtension({
  build(editor, config, state) {
    return namedSignals(config);
  },
  config: safeCast({
    disabled: false,
    maxIndent: null
  }),
  name: "@lexical/extension/TabIndentation",
  register(editor, config, state) {
    const {
      disabled,
      maxIndent
    } = state.getOutput();
    return E(() => {
      if (!disabled.value) {
        return registerTabIndentation(editor, maxIndent);
      }
    });
  }
});

export {
  o,
  E,
  namedSignals,
  LexicalBuilder,
  getPeerDependencyFromEditor
};
//# sourceMappingURL=chunk-TEIZQBHD.js.map
