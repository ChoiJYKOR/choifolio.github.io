import {
  $canShowPlaceholderCurry
} from "./chunk-6NZI6TKD.js";
import {
  registerDragonSupport,
  registerRichText
} from "./chunk-7ID47EY7.js";
import "./chunk-ECJFCOSY.js";
import {
  useLexicalComposerContext
} from "./chunk-SIE2AFNC.js";
import {
  require_jsx_runtime
} from "./chunk-KJLTMZG4.js";
import {
  LexicalBuilder
} from "./chunk-TEIZQBHD.js";
import {
  mergeRegister
} from "./chunk-TLVVYBXE.js";
import {
  defineExtension
} from "./chunk-Z553WKUN.js";
import {
  require_react_dom
} from "./chunk-5W5GC63A.js";
import {
  require_react
} from "./chunk-ZVH3J77E.js";
import {
  __toESM
} from "./chunk-J32WSRGE.js";

// node_modules/@lexical/react/useLexicalEditable.dev.mjs
var import_react = __toESM(require_react(), 1);
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl = CAN_USE_DOM ? import_react.useLayoutEffect : import_react.useEffect;
function useLexicalSubscription(subscription2) {
  const [editor] = useLexicalComposerContext();
  const initializedSubscription = (0, import_react.useMemo)(() => subscription2(editor), [editor, subscription2]);
  const [value, setValue] = (0, import_react.useState)(() => initializedSubscription.initialValueFn());
  const valueRef = (0, import_react.useRef)(value);
  useLayoutEffectImpl(() => {
    const {
      initialValueFn,
      subscribe
    } = initializedSubscription;
    const currentValue = initialValueFn();
    if (valueRef.current !== currentValue) {
      valueRef.current = currentValue;
      setValue(currentValue);
    }
    return subscribe((newValue) => {
      valueRef.current = newValue;
      setValue(newValue);
    });
  }, [initializedSubscription, subscription2]);
  return value;
}
function subscription(editor) {
  return {
    initialValueFn: () => editor.isEditable(),
    subscribe: (callback) => {
      return editor.registerEditableListener(callback);
    }
  };
}
function useLexicalEditable() {
  return useLexicalSubscription(subscription);
}

// node_modules/@lexical/react/LexicalReactProviderExtension.dev.mjs
var ReactProviderExtension = defineExtension({
  name: "@lexical/react/ReactProvider"
});

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs
var import_react2 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function formatDevErrorMessage(message) {
  throw new Error(message);
}
var CAN_USE_DOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl2 = CAN_USE_DOM2 ? import_react2.useLayoutEffect : import_react2.useEffect;
function useDecorators(editor, ErrorBoundary) {
  const [decorators, setDecorators] = (0, import_react2.useState)(() => editor.getDecorators());
  useLayoutEffectImpl2(() => {
    return editor.registerDecoratorListener((nextDecorators) => {
      (0, import_react_dom.flushSync)(() => {
        setDecorators(nextDecorators);
      });
    });
  }, [editor]);
  (0, import_react2.useEffect)(() => {
    setDecorators(editor.getDecorators());
  }, [editor]);
  return (0, import_react2.useMemo)(() => {
    const decoratedPortals = [];
    const decoratorKeys = Object.keys(decorators);
    for (let i = 0; i < decoratorKeys.length; i++) {
      const nodeKey = decoratorKeys[i];
      const reactDecorator = (0, import_jsx_runtime.jsx)(ErrorBoundary, {
        onError: (e) => editor._onError(e),
        children: (0, import_jsx_runtime.jsx)(import_react2.Suspense, {
          fallback: null,
          children: decorators[nodeKey]
        })
      });
      const element = editor.getElementByKey(nodeKey);
      if (element !== null) {
        decoratedPortals.push((0, import_react_dom.createPortal)(reactDecorator, element, nodeKey));
      }
    }
    return decoratedPortals;
  }, [ErrorBoundary, decorators, editor]);
}
function isUsingReactExtension(editor) {
  const builder = LexicalBuilder.maybeFromEditor(editor);
  if (builder && builder.hasExtensionByName(ReactProviderExtension.name)) {
    for (const name of ["@lexical/plain-text", "@lexical/rich-text"]) {
      if (!!builder.hasExtensionByName(name)) {
        formatDevErrorMessage(`LexicalBuilder: @lexical/react legacy text plugins conflict with the ${name} extension. Remove the legacy <RichTextPlugin/> or <PlainTextPlugin/> component.`);
      }
    }
    return true;
  }
  return false;
}
function Decorators({
  editor,
  ErrorBoundary
}) {
  return useDecorators(editor, ErrorBoundary);
}
function LegacyDecorators({
  editor,
  ErrorBoundary
}) {
  return isUsingReactExtension(editor) ? null : (0, import_jsx_runtime.jsx)(Decorators, {
    editor,
    ErrorBoundary
  });
}
function canShowPlaceholderFromCurrentEditorState(editor) {
  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));
  return currentCanShowPlaceholder;
}
function useCanShowPlaceholder(editor) {
  const [canShowPlaceholder, setCanShowPlaceholder] = (0, import_react2.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));
  useLayoutEffectImpl2(() => {
    function resetCanShowPlaceholder() {
      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);
      setCanShowPlaceholder(currentCanShowPlaceholder);
    }
    resetCanShowPlaceholder();
    return mergeRegister(editor.registerUpdateListener(() => {
      resetCanShowPlaceholder();
    }), editor.registerEditableListener(() => {
      resetCanShowPlaceholder();
    }));
  }, [editor]);
  return canShowPlaceholder;
}
function useRichTextSetup(editor) {
  useLayoutEffectImpl2(() => {
    return mergeRegister(registerRichText(editor), registerDragonSupport(editor));
  }, [editor]);
}
function RichTextPlugin({
  contentEditable,
  // TODO Remove. This property is now part of ContentEditable
  placeholder = null,
  ErrorBoundary
}) {
  const [editor] = useLexicalComposerContext();
  useRichTextSetup(editor);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [contentEditable, (0, import_jsx_runtime.jsx)(Placeholder, {
      content: placeholder
    }), (0, import_jsx_runtime.jsx)(LegacyDecorators, {
      editor,
      ErrorBoundary
    })]
  });
}
function Placeholder({
  content
}) {
  const [editor] = useLexicalComposerContext();
  const showPlaceholder = useCanShowPlaceholder(editor);
  const editable = useLexicalEditable();
  if (!showPlaceholder) {
    return null;
  }
  if (typeof content === "function") {
    return content(editable);
  } else {
    return content;
  }
}
export {
  RichTextPlugin
};
//# sourceMappingURL=@lexical_react_LexicalRichTextPlugin.js.map
