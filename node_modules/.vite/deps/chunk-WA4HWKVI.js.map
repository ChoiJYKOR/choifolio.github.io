{
  "version": 3,
  "sources": ["../../@lexical/link/LexicalLink.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement, $findMatchingParent, mergeRegister, objectKlassEquals } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection, $isNodeSelection, $normalizeSelection__EXPERIMENTAL, $setSelection, defineExtension, COMMAND_PRIORITY_LOW, PASTE_COMMAND, safeCast, isDOMNode, getNearestEditorFromDOMNode, $getNearestNodeFromDOMNode, shallowMergeConfig, TextNode, $isTextNode, $isLineBreakNode, $createTextNode } from 'lexical';\nimport { namedSignals, effect } from '@lexical/extension';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n  __url;\n  /** @internal */\n  __target;\n  /** @internal */\n  __rel;\n  /** @internal */\n  __title;\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if (isHTMLAnchorElement(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n  __isUnlinked;\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!$isElementNode(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = $getSelection();\n  if (!$isRangeSelection(initialSelection)) {\n    return $fn();\n  }\n  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = $getSelection();\n    if ($isRangeSelection(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      $setSelection($normalizeSelection__EXPERIMENTAL(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param urlOrAttributes - The URL the link directs to, or an attributes object with an url property\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(urlOrAttributes, attributes = {}) {\n  let url;\n  if (urlOrAttributes && typeof urlOrAttributes === 'object') {\n    const {\n      url: urlProp,\n      ...rest\n    } = urlOrAttributes;\n    url = urlProp;\n    attributes = {\n      ...rest,\n      ...attributes\n    };\n  } else {\n    url = urlOrAttributes;\n  }\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (selection === null || !$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n    return;\n  }\n  if ($isNodeSelection(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $findMatchingParent(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $findMatchingParent(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ($isElementNode(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst defaultProps = {\n  attributes: undefined,\n  validateUrl: undefined\n};\n\n/** @internal */\nfunction registerLink(editor, stores) {\n  return mergeRegister(effect(() => editor.registerCommand(TOGGLE_LINK_COMMAND, payload => {\n    const validateUrl = stores.validateUrl.peek();\n    const attributes = stores.attributes.peek();\n    if (payload === null) {\n      $toggleLink(null);\n      return true;\n    } else if (typeof payload === 'string') {\n      if (validateUrl === undefined || validateUrl(payload)) {\n        $toggleLink(payload, attributes);\n        return true;\n      }\n      return false;\n    } else {\n      const {\n        url,\n        target,\n        rel,\n        title\n      } = payload;\n      $toggleLink(url, {\n        ...attributes,\n        rel,\n        target,\n        title\n      });\n      return true;\n    }\n  }, COMMAND_PRIORITY_LOW)), effect(() => {\n    const validateUrl = stores.validateUrl.value;\n    if (!validateUrl) {\n      return;\n    }\n    const attributes = stores.attributes.value;\n    return editor.registerCommand(PASTE_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || selection.isCollapsed() || !objectKlassEquals(event, ClipboardEvent)) {\n        return false;\n      }\n      if (event.clipboardData === null) {\n        return false;\n      }\n      const clipboardText = event.clipboardData.getData('text');\n      if (!validateUrl(clipboardText)) {\n        return false;\n      }\n      // If we select nodes that are elements then avoid applying the link.\n      if (!selection.getNodes().some(node => $isElementNode(node))) {\n        editor.dispatchCommand(TOGGLE_LINK_COMMAND, {\n          ...attributes,\n          url: clipboardText\n        });\n        event.preventDefault();\n        return true;\n      }\n      return false;\n    }, COMMAND_PRIORITY_LOW);\n  }));\n}\n\n/**\n * Provides {@link LinkNode}, an implementation of\n * {@link TOGGLE_LINK_COMMAND}, and a {@link PASTE_COMMAND}\n * listener to wrap selected nodes in a link when a\n * URL is pasted and `validateUrl` is defined.\n */\nconst LinkExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: defaultProps,\n  name: '@lexical/link/Link',\n  nodes: [LinkNode],\n  register(editor, config, state) {\n    return registerLink(editor, state.getOutput());\n  }\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findMatchingDOM(startNode, predicate) {\n  let node = startNode;\n  while (node != null) {\n    if (predicate(node)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nfunction registerClickableLink(editor, stores, eventOptions = {}) {\n  const onClick = event => {\n    const target = event.target;\n    if (!isDOMNode(target)) {\n      return;\n    }\n    const nearestEditor = getNearestEditorFromDOMNode(target);\n    if (nearestEditor === null) {\n      return;\n    }\n    let url = null;\n    let urlTarget = null;\n    nearestEditor.update(() => {\n      const clickedNode = $getNearestNodeFromDOMNode(target);\n      if (clickedNode !== null) {\n        const maybeLinkNode = $findMatchingParent(clickedNode, $isElementNode);\n        if (!stores.disabled.peek()) {\n          if ($isLinkNode(maybeLinkNode)) {\n            url = maybeLinkNode.sanitizeUrl(maybeLinkNode.getURL());\n            urlTarget = maybeLinkNode.getTarget();\n          } else {\n            const a = findMatchingDOM(target, isHTMLAnchorElement);\n            if (a !== null) {\n              url = a.href;\n              urlTarget = a.target;\n            }\n          }\n        }\n      }\n    });\n    if (url === null || url === '') {\n      return;\n    }\n\n    // Allow user to select link text without following url\n    const selection = editor.getEditorState().read($getSelection);\n    if ($isRangeSelection(selection) && !selection.isCollapsed()) {\n      event.preventDefault();\n      return;\n    }\n    const isMiddle = event.type === 'auxclick' && event.button === 1;\n    window.open(url, stores.newTab.peek() || isMiddle || event.metaKey || event.ctrlKey || urlTarget === '_blank' ? '_blank' : '_self');\n    event.preventDefault();\n  };\n  const onMouseUp = event => {\n    if (event.button === 1) {\n      onClick(event);\n    }\n  };\n  return editor.registerRootListener((rootElement, prevRootElement) => {\n    if (prevRootElement !== null) {\n      prevRootElement.removeEventListener('click', onClick);\n      prevRootElement.removeEventListener('mouseup', onMouseUp);\n    }\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', onClick, eventOptions);\n      rootElement.addEventListener('mouseup', onMouseUp, eventOptions);\n    }\n  });\n}\n\n/**\n * Normally in a Lexical editor the `CLICK_COMMAND` on a LinkNode will cause the\n * selection to change instead of opening a link. This extension can be used to\n * restore the default behavior, e.g. when the editor is not editable.\n */\nconst ClickableLinkExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: safeCast({\n    disabled: false,\n    newTab: false\n  }),\n  dependencies: [LinkExtension],\n  name: '@lexical/link/ClickableLink',\n  register(editor, config, state) {\n    return registerClickableLink(editor, state.getOutput());\n  }\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createLinkMatcherWithRegExp(regExp, urlTransformer = text => text) {\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) {\n      return null;\n    }\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0])\n    };\n  };\n}\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\n\n/**\n * Check if the text content starts with a fullstop followed by a top-level domain.\n * Meaning if the text content can be a beginning of a top level domain.\n * @param textContent\n * @param isEmail\n * @returns boolean\n */\nfunction startsWithTLD(textContent, isEmail) {\n  if (isEmail) {\n    return /^\\.[a-zA-Z]{2,}/.test(textContent);\n  } else {\n    return /^\\.[a-zA-Z0-9]{1,}/.test(textContent);\n  }\n}\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n  return previousNode === null || $isLineBreakNode(previousNode) || $isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n  return nextNode === null || $isLineBreakNode(nextNode) || $isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\nfunction isContentAroundIsValid(matchStart, matchEnd, text, nodes) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]);\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);\n  return contentAfterIsValid;\n}\nfunction extractMatchingNodes(nodes, startIndex, endIndex) {\n  const unmodifiedBeforeNodes = [];\n  const matchingNodes = [];\n  const unmodifiedAfterNodes = [];\n  let matchingOffset = 0;\n  let currentOffset = 0;\n  const currentNodes = [...nodes];\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0];\n    const currentNodeText = currentNode.getTextContent();\n    const currentNodeLength = currentNodeText.length;\n    const currentNodeStart = currentOffset;\n    const currentNodeEnd = currentOffset + currentNodeLength;\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode);\n      matchingOffset += currentNodeLength;\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode);\n    } else {\n      matchingNodes.push(currentNode);\n    }\n    currentOffset += currentNodeLength;\n    currentNodes.shift();\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];\n}\nfunction $createAutoLinkNode_(nodes, startIndex, endIndex, match) {\n  const linkNode = $createAutoLinkNode(match.url, match.attributes);\n  if (nodes.length === 1) {\n    let remainingTextNode = nodes[0];\n    let linkTextNode;\n    if (startIndex === 0) {\n      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);\n    } else {\n      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);\n    }\n    const textNode = $createTextNode(match.text);\n    textNode.setFormat(linkTextNode.getFormat());\n    textNode.setDetail(linkTextNode.getDetail());\n    textNode.setStyle(linkTextNode.getStyle());\n    linkNode.append(textNode);\n    linkTextNode.replace(linkNode);\n    return remainingTextNode;\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0];\n    let offset = firstTextNode.getTextContent().length;\n    let firstLinkTextNode;\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode;\n    } else {\n      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);\n    }\n    const linkNodes = [];\n    let remainingTextNode;\n    for (let i = 1; i < nodes.length; i++) {\n      const currentNode = nodes[i];\n      const currentNodeText = currentNode.getTextContent();\n      const currentNodeLength = currentNodeText.length;\n      const currentNodeStart = offset;\n      const currentNodeEnd = offset + currentNodeLength;\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode);\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);\n          linkNodes.push(linkTextNode);\n          remainingTextNode = endNode;\n        }\n      }\n      offset += currentNodeLength;\n    }\n    const selection = $getSelection();\n    const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined;\n    const textNode = $createTextNode(firstLinkTextNode.getTextContent());\n    textNode.setFormat(firstLinkTextNode.getFormat());\n    textNode.setDetail(firstLinkTextNode.getDetail());\n    textNode.setStyle(firstLinkTextNode.getStyle());\n    linkNode.append(textNode, ...linkNodes);\n    // it does not preserve caret position if caret was at the first text node\n    // so we need to restore caret position\n    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n      if ($isRangeSelection(selection)) {\n        textNode.select(selection.anchor.offset, selection.focus.offset);\n      } else if ($isNodeSelection(selection)) {\n        textNode.select(0, textNode.getTextContent().length);\n      }\n    }\n    firstLinkTextNode.replace(linkNode);\n    return remainingTextNode;\n  }\n  return undefined;\n}\nfunction $handleLinkCreation(nodes, matchers, onChange) {\n  let currentNodes = [...nodes];\n  const initialText = currentNodes.map(node => node.getTextContent()).join('');\n  let text = initialText;\n  let match;\n  let invalidMatchEnd = 0;\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);\n    if (isValid) {\n      const [matchingOffset,, matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;\n      const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);\n      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n    text = text.substring(matchEnd);\n  }\n}\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n  const url = linkNode.getURL();\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n    const target = linkNode.getTarget();\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n  if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text) || startsWithTLD(text, previousSibling.isEmailURI()))) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n  if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n  node.remove();\n  return children.map(child => child.getLatest());\n}\nfunction getTextNodesToMatch(textNode) {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode];\n  let nextSibling = textNode.getNextSibling();\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling);\n    if (/[\\s]/.test(nextSibling.getTextContent())) {\n      break;\n    }\n    nextSibling = nextSibling.getNextSibling();\n  }\n  return textNodesToMatch;\n}\nconst defaultConfig = {\n  changeHandlers: [],\n  matchers: []\n};\nfunction registerAutoLink(editor, config = defaultConfig) {\n  const {\n    matchers,\n    changeHandlers\n  } = config;\n  const onChange = (url, prevUrl) => {\n    for (const handler of changeHandlers) {\n      handler(url, prevUrl);\n    }\n  };\n  return mergeRegister(editor.registerNodeTransform(TextNode, textNode => {\n    const parent = textNode.getParentOrThrow();\n    const previous = textNode.getPreviousSibling();\n    if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {\n      handleLinkEdit(parent, matchers, onChange);\n    } else if (!$isLinkNode(parent)) {\n      if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))) {\n        const textNodesToMatch = getTextNodesToMatch(textNode);\n        $handleLinkCreation(textNodesToMatch, matchers, onChange);\n      }\n      handleBadNeighbors(textNode, matchers, onChange);\n    }\n  }), editor.registerCommand(TOGGLE_LINK_COMMAND, payload => {\n    const selection = $getSelection();\n    if (payload !== null || !$isRangeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.extract();\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if ($isAutoLinkNode(parent)) {\n        // invert the value\n        parent.setIsUnlinked(!parent.getIsUnlinked());\n        parent.markDirty();\n      }\n    });\n    return false;\n  }, COMMAND_PRIORITY_LOW));\n}\n\n/**\n * An extension to automatically create AutoLinkNode from text\n * that matches the configured matchers. No default implementation\n * is provided for any matcher, see {@link createLinkMatcherWithRegExp}\n * for a helper function to create a matcher from a RegExp, and the\n * Playground's [AutoLinkPlugin](https://github.com/facebook/lexical/blob/main/packages/lexical-playground/src/plugins/AutoLinkPlugin/index.tsx)\n * for some example RegExps that could be used.\n *\n * The given `matchers` and `changeHandlers` will be merged by\n * concatenating the configured arrays.\n */\nconst AutoLinkExtension = defineExtension({\n  config: defaultConfig,\n  dependencies: [LinkExtension],\n  mergeConfig(config, overrides) {\n    const merged = shallowMergeConfig(config, overrides);\n    for (const k of ['matchers', 'changeHandlers']) {\n      const v = overrides[k];\n      if (Array.isArray(v)) {\n        merged[k] = [...config[k], ...v];\n      }\n    }\n    return merged;\n  },\n  name: '@lexical/link/AutoLink',\n  register: registerAutoLink\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkExtension, AutoLinkNode, ClickableLinkExtension, LinkExtension, LinkNode, TOGGLE_LINK_COMMAND, createLinkMatcherWithRegExp, formatUrl, registerAutoLink, registerClickableLink, registerLink, toggleLink };\n"],
  "mappings": "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",
  "names": ["nodes"]
}
