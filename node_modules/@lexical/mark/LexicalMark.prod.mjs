/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{ElementNode as t,$isRangeSelection as e,$applyNodeReplacement as r,defineExtension as n,$createRangeSelection as s,$isElementNode as i,$isTextNode as o,$isDecoratorNode as c}from"lexical";import{addClassNamesToElement as u,removeClassNamesFromElement as l}from"@lexical/utils";const a=[];class f extends t{__ids;static getType(){return"mark"}static clone(t){return new f(t.__ids,t.__key)}static importDOM(){return null}static importJSON(t){return d().updateFromJSON(t)}updateFromJSON(t){return super.updateFromJSON(t).setIDs(t.ids)}exportJSON(){return{...super.exportJSON(),ids:this.getIDs()}}constructor(t=a,e){super(e),this.__ids=t}createDOM(t){const e=document.createElement("mark");return u(e,t.theme.mark),this.__ids.length>1&&u(e,t.theme.markOverlap),e}updateDOM(t,e,r){const n=t.__ids,s=this.__ids,i=n.length,o=s.length,c=r.theme.markOverlap;return i!==o&&(1===i?2===o&&u(e,c):1===o&&l(e,c)),!1}hasID(t){return this.getIDs().includes(t)}getIDs(){return Array.from(this.getLatest().__ids)}setIDs(t){const e=this.getWritable();return e.__ids=t,e}addID(t){const e=this.getWritable();return e.__ids.includes(t)?e:e.setIDs([...e.__ids,t])}deleteID(t){const e=this.getWritable(),r=e.__ids.indexOf(t);if(-1===r)return e;const n=Array.from(e.__ids);return n.splice(r,1),e.setIDs(n)}insertNewAfter(t,e=!0){const r=d(this.__ids);return this.insertAfter(r,e),r}canInsertTextBefore(){return!1}canInsertTextAfter(){return!1}canBeEmpty(){return!1}isInline(){return!0}extractWithChild(t,r,n){if(!e(r)||"html"===n)return!1;const s=r.anchor,i=r.focus,o=s.getNode(),c=i.getNode(),u=r.isBackward()?s.offset-i.offset:i.offset-s.offset;return this.isParentOf(o)&&this.isParentOf(c)&&this.getTextContent().length===u}excludeFromCopy(t){return"clone"!==t}}function d(t=a){return r(new f(t))}function h(t){return t instanceof f}function _(t){const e=t.getChildren();let r=null;for(let n=0;n<e.length;n++){const s=e[n];null===r?t.insertBefore(s):r.insertAfter(s),r=s}t.remove()}function m(t,e,r,n){const u=s(),[l,a]=t.isBackward()?[t.focus,t.anchor]:[t.anchor,t.focus];let f,_;u.anchor.set(l.key,l.offset,l.type),u.focus.set(a.key,a.offset,a.type);const m=u.extract();for(const t of m){if(i(_)&&_.isParentOf(t))continue;let e=null;if(o(t))e=t;else{if(h(t))continue;(i(t)||c(t))&&t.isInline()&&(e=t)}if(null!==e){if(e&&e.is(f))continue;const t=e.getParent();if(null!=t&&t.is(f)||(_=void 0),f=t,void 0===_){_=(n||d)([r]),e.insertBefore(_)}_.append(e)}else f=void 0,_=void 0}i(_)&&(e?_.selectStart():_.selectEnd())}function g(t,e){let r=t;for(;null!==r;){if(h(r))return r.getIDs();if(o(r)&&e===r.getTextContentSize()){const t=r.getNextSibling();if(h(t))return t.getIDs()}r=r.getParent()}return null}const p=n({name:"@lexical/mark",nodes:[f]});export{d as $createMarkNode,g as $getMarkIDs,h as $isMarkNode,_ as $unwrapMarkNode,m as $wrapSelectionInMarkNode,p as MarkExtension,f as MarkNode};
